{
  "data": {
    "lesson": {
      "id": 267180,
      "key": "2fd24529-215c-47b5-a644-2c23650493f6",
      "title": "Convolutional Networks",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Vincent explains the theory behind Convolutional Neural Networks and how they help us dramatically improve performance in image classification.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": null,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/2fd24529-215c-47b5-a644-2c23650493f6/267180/1544457415614/Convolutional+Networks+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/2fd24529-215c-47b5-a644-2c23650493f6/267180/1544457412219/Convolutional+Networks+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 134287,
          "key": "63741833610923",
          "title": "Intro To CNNs",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 31466,
              "key": "6374183361",
              "title": "Intro to CNNs",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "B61jxZ4rkMs",
                "china_cdn_id": "B61jxZ4rkMs.mp4"
              }
            }
          ]
        },
        {
          "id": 268050,
          "key": "f2ff6541-30f0-4437-9f07-22c91c384fcd",
          "title": "Color",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 268051,
              "key": "f55a2905-c8c2-47da-aae7-652557086d79",
              "title": "Color-Question",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "BdQccpMwk80",
                "china_cdn_id": "BdQccpMwk80.mp4"
              }
            },
            {
              "id": 268052,
              "key": "4f6d9610-d4e6-47e0-a35c-3e81131fa0f5",
              "title": "Color",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What would be easier for your classifier to learn?",
                "answers": [
                  {
                    "id": "a1487817099326",
                    "text": "R, G, B",
                    "is_correct": false
                  },
                  {
                    "id": "a1487817106603",
                    "text": "(R + G + B) / 3",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 267997,
          "key": "0814ce97-5008-432a-b28c-f483b7472965",
          "title": "Statistical Invariance",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 267998,
              "key": "49b8168f-fa5e-490d-86a2-45d87cd1f4b3",
              "title": "Statistical Invariance",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "0Hr5YwUUhr0",
                "china_cdn_id": "0Hr5YwUUhr0.mp4"
              }
            }
          ]
        },
        {
          "id": 268000,
          "key": "30ecc31b-f1b6-49c7-8e67-6757a9a1bb8b",
          "title": "Convolutional Networks",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 268001,
              "key": "e3f5d200-347f-455a-a1bb-e19e0dceb53e",
              "title": "Convolutional Networks",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ISHGyvsT0QY",
                "china_cdn_id": "ISHGyvsT0QY.mp4"
              }
            }
          ]
        },
        {
          "id": 216734,
          "key": "da532f3b-29e8-43d1-9590-aa58909c28d1",
          "title": "Intuition",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 216735,
              "key": "981e7cdf-7f24-436c-beb6-1606f72f1502",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Intuition\n\nLet's develop better intuition for how Convolutional Neural Networks (CNN) work. We'll examine how humans classify images, and then see how CNNs use similar approaches.\n\nLet’s say we wanted to classify the following image of a dog as a Golden Retriever.\n",
              "instructor_notes": ""
            },
            {
              "id": 216736,
              "key": "aa96d6e5-db9d-44eb-ac45-111fe3b9c105",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377b77_dog-1210559-1280/dog-1210559-1280.jpg",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/aa96d6e5-db9d-44eb-ac45-111fe3b9c105",
              "caption": "An image that we'd like to classify as a Golden Retriever.",
              "alt": null,
              "width": 1280,
              "height": 960,
              "instructor_notes": null
            },
            {
              "id": 216737,
              "key": "cc60843a-7530-4492-b4db-40b3274e7581",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "As humans, how do we do this? \n\nOne thing we do is that we identify certain parts of the dog, such as the nose, the eyes, and the fur. We essentially break up the image into smaller pieces, recognize the smaller pieces, and then combine those pieces to get an idea of the overall dog.\n\nIn this case, we might break down the image into a combination of the following:\n\n- A nose\n- Two eyes\n- Golden fur\n\nThese pieces can be seen below:",
              "instructor_notes": ""
            },
            {
              "id": 216738,
              "key": "c0726277-4ce5-439b-9002-09b3afa237b1",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377bdb_screen-shot-2016-11-24-at-12.49.08-pm/screen-shot-2016-11-24-at-12.49.08-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/c0726277-4ce5-439b-9002-09b3afa237b1",
              "caption": "The eye of the dog.",
              "alt": null,
              "width": 208,
              "height": 208,
              "instructor_notes": null
            },
            {
              "id": 216739,
              "key": "c51c102b-d377-456e-8c09-edb54c70634c",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377bed_screen-shot-2016-11-24-at-12.49.43-pm/screen-shot-2016-11-24-at-12.49.43-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/c51c102b-d377-456e-8c09-edb54c70634c",
              "caption": "The nose of the dog.",
              "alt": null,
              "width": 208,
              "height": 208,
              "instructor_notes": null
            },
            {
              "id": 216740,
              "key": "d851a50d-b7d2-4802-92f7-4f95e39206f8",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377bff_screen-shot-2016-11-24-at-12.50.54-pm/screen-shot-2016-11-24-at-12.50.54-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/d851a50d-b7d2-4802-92f7-4f95e39206f8",
              "caption": "The fur of the dog.",
              "alt": null,
              "width": 208,
              "height": 208,
              "instructor_notes": null
            },
            {
              "id": 216741,
              "key": "37c9621d-4b4f-42b1-8557-6fc474708ddb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Going One Step Further\n\nBut let’s take this one step further. How do we determine what exactly a nose is? A Golden Retriever nose can be seen as an oval with two black holes inside it. Thus, one way of classifying a Retriever’s nose is to to break it up into smaller pieces and look for black holes (nostrils) and curves that define an oval as shown below.\n",
              "instructor_notes": ""
            },
            {
              "id": 216742,
              "key": "b86fec5d-77f1-4f93-9e5d-7a1044cd0be6",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377c52_screen-shot-2016-11-24-at-12.51.47-pm/screen-shot-2016-11-24-at-12.51.47-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/b86fec5d-77f1-4f93-9e5d-7a1044cd0be6",
              "caption": "A curve that we can use to determine a nose.",
              "alt": null,
              "width": 206,
              "height": 62,
              "instructor_notes": null
            },
            {
              "id": 216743,
              "key": "b58e8f01-af9c-4dbe-8a51-43b49d41fbde",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377c68_screen-shot-2016-11-24-at-12.51.51-pm/screen-shot-2016-11-24-at-12.51.51-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/b58e8f01-af9c-4dbe-8a51-43b49d41fbde",
              "caption": "A nostril that we can use to classify a nose of the dog.",
              "alt": null,
              "width": 64,
              "height": 86,
              "instructor_notes": null
            },
            {
              "id": 216744,
              "key": "22c5f9fe-8c01-4559-9636-4685599f5473",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Broadly speaking, this is what a CNN learns to do. It learns to recognize basic lines and curves, then shapes and blobs, and then increasingly complex objects within the image. Finally, the CNN classifies the image by combining the larger, more complex objects. \n\nIn our case, the levels in the hierarchy are:\n\n- Simple shapes, like ovals and dark circles\n- Complex objects (combinations of simple shapes), like eyes, nose, and fur\n- The dog as a whole (a combination of complex objects)\n\nWith deep learning, we don't actually program the CNN to recognize these specific features. Rather, the CNN learns on its own to recognize such objects through forward propagation and backpropagation! \n\nIt's amazing how well a CNN can learn to classify images, even though we never program the CNN with information about specific features to look for.",
              "instructor_notes": ""
            },
            {
              "id": 217344,
              "key": "277d41f9-189d-4b45-9453-d7c6f903f89b",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/583cb19d_heirarchy-diagram/heirarchy-diagram.jpg",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/277d41f9-189d-4b45-9453-d7c6f903f89b",
              "caption": "An example of what each layer in a CNN might recognize when classifying a picture of a dog.",
              "alt": null,
              "width": 765,
              "height": 549,
              "instructor_notes": null
            },
            {
              "id": 217343,
              "key": "92aa4d34-d3f0-4462-ad4e-08a50e9f432b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "A CNN might have several layers, and each layer might capture a different level in the hierarchy of objects. The first layer is the lowest level in the hierarchy, where the CNN generally classifies small parts of the image into simple shapes like horizontal and vertical lines and simple blobs of colors. The subsequent layers tend to be higher levels in the hierarchy and generally classify more complex ideas like shapes (combinations of lines), and eventually full objects like dogs. \n\nOnce again, the CNN ***learns all of this on its own***. We don't ever have to tell the CNN to go looking for lines or curves or noses or fur. The CNN just learns from the training set and discovers which characteristics of a Golden Retriever are worth looking for.\n\nThat's a good start! Hopefully you've developed some intuition about how CNNs work.\n\nNext, let’s look at some implementation details.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217773,
          "key": "bed725a8-0738-4b00-92bd-d2062f005a7c",
          "title": "Filters",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217774,
              "key": "bffcee09-e532-4860-9041-fe528842665d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Breaking up an Image\n\nThe first step for a CNN is to break up the image into smaller pieces. We do this by selecting a width and height that defines a filter.\n\nThe filter looks at small pieces, or patches, of the image. These patches are the same size as the filter. ",
              "instructor_notes": ""
            },
            {
              "id": 217775,
              "key": "a3922280-56de-4ad6-8084-d21ccea24f2f",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377d67_vlcsnap-2016-11-24-15h52m47s438/vlcsnap-2016-11-24-15h52m47s438.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/a3922280-56de-4ad6-8084-d21ccea24f2f",
              "caption": "As shown in the previous video, a CNN uses filters to split an image into smaller patches. The size of these patches matches the filter size.",
              "alt": null,
              "width": 1280,
              "height": 738,
              "instructor_notes": null
            },
            {
              "id": 217776,
              "key": "df216b4f-9644-4676-9e88-1cc370fda019",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We then simply slide this filter horizontally or vertically to focus on a different piece of the image. \n\nThe amount by which the filter slides is referred to as the 'stride'. The stride is a hyperparameter which you, the engineer, can tune. Increasing the stride reduces the size of your model by reducing the number of total patches each layer observes. However, this usually comes with a reduction in accuracy.\n\nLet’s look at an example. In this zoomed in image of the dog, we first start with the patch outlined in red. The width and height of our filter define the size of this square.",
              "instructor_notes": ""
            },
            {
              "id": 217777,
              "key": "87549295-db45-4eb3-9085-c7bf02cd4367",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/December/5840fdac_retriever-patch/retriever-patch.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/87549295-db45-4eb3-9085-c7bf02cd4367",
              "caption": "One patch of the Golden Retriever image.",
              "alt": null,
              "width": 1902,
              "height": 1502,
              "instructor_notes": null
            },
            {
              "id": 217778,
              "key": "6bdd5960-fa6b-4619-91f9-af26c0cf0650",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We then move the square over to the right by a given stride (2 in this case) to get another patch.",
              "instructor_notes": ""
            },
            {
              "id": 217779,
              "key": "2cf8a023-b9c9-4712-9ab0-f410e990b96f",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/December/5840fe04_retriever-patch-shifted/retriever-patch-shifted.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/2cf8a023-b9c9-4712-9ab0-f410e990b96f",
              "caption": "We move our square to the right by two pixels to create another patch.",
              "alt": null,
              "width": 1904,
              "height": 1506,
              "instructor_notes": null
            },
            {
              "id": 217780,
              "key": "2507e583-297a-4de4-aecc-0887525d5de8",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "What's important here is that we are **grouping together adjacent pixels** and treating them as a collective. \n\nIn a normal, non-convolutional neural network, we would have ignored this adjacency. In a normal network, we would have connected every pixel in the input image to a neuron in the next layer. In doing so, we would not have taken advantage of the fact that pixels in an image are close together for a reason and have special meaning. \n\nBy taking advantage of this local structure, our CNN learns to classify local patterns, like shapes and objects, in an image.",
              "instructor_notes": ""
            },
            {
              "id": 217781,
              "key": "cd0004cd-3a85-46fa-a46b-02874ebf9a0c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Filter Depth\n\nIt's common to have more than one filter. Different filters pick up different qualities of a patch. For example, one filter might look for a particular color, while another might look for a kind of object of a specific shape. The amount of filters in a convolutional layer is called the *filter depth*.",
              "instructor_notes": ""
            },
            {
              "id": 217782,
              "key": "3af04f74-fc45-4cf4-8387-ae4511e4b86a",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377e4f_neilsen-pic/neilsen-pic.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/3af04f74-fc45-4cf4-8387-ae4511e4b86a",
              "caption": "In the above example, a patch is connected to a neuron in the next layer. Source: MIchael Nielsen.",
              "alt": null,
              "width": 353,
              "height": 258,
              "instructor_notes": null
            },
            {
              "id": 217783,
              "key": "ea641478-9f33-4730-afdb-540af71e4633",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "How many neurons does each patch connect to? \n\nThat’s dependent on our filter depth. If we have a depth of `k`, we connect each patch of pixels to `k` neurons in the next layer. This gives us the height of `k` in the next layer, as shown below. In practice, `k` is a hyperparameter we tune, and most CNNs tend to pick the same starting values.",
              "instructor_notes": ""
            },
            {
              "id": 217784,
              "key": "fa6c2e6d-1bd6-4f0a-8566-e57b4fd9306d",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/December/5840ffda_filter-depth/filter-depth.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/fa6c2e6d-1bd6-4f0a-8566-e57b4fd9306d",
              "caption": "Choosing a filter depth of `k` connects each patch to `k` neurons in the next layer.",
              "alt": null,
              "width": 606,
              "height": 1010,
              "instructor_notes": null
            },
            {
              "id": 217785,
              "key": "44c5ccb8-cf3b-4bbf-8a50-223b036359e2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "But why connect a single patch to multiple neurons in the next layer? Isn’t one neuron good enough?\n\nMultiple neurons can be useful because a patch can have multiple interesting characteristics that we want to capture. \n\nFor example, one patch might include some white teeth, some blonde whiskers, and part of a red tongue. In that case, we might want a filter depth of at least three - one for each of teeth, whiskers, and tongue.",
              "instructor_notes": ""
            },
            {
              "id": 217786,
              "key": "a5819d86-3180-412a-827f-fec39a336740",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/December/584104c8_teeth-whiskers-tongue/teeth-whiskers-tongue.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/a5819d86-3180-412a-827f-fec39a336740",
              "caption": "This patch of the dog has many interesting features we may want to capture. These include the presence of teeth, the presence of whiskers, and the pink color of the tongue.",
              "alt": null,
              "width": 388,
              "height": 420,
              "instructor_notes": null
            },
            {
              "id": 217787,
              "key": "ca766777-9d37-4621-9808-75ae078266d6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Having multiple neurons for a given patch ensures that our CNN can learn to capture whatever characteristics the CNN learns are important.\n\nRemember that the CNN isn't \"programmed\" to look for certain characteristics. Rather, it learns **on its own** which characteristics to notice.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 268053,
          "key": "43de97fc-058a-48cc-84a3-4b68246e7a39",
          "title": "Feature Map Sizes",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 268056,
              "key": "5717cfe2-a602-4e16-b5e5-222a74bc94a8",
              "title": "Feature-Map-Sizes-Question",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "lp1NrLZnCUM",
                "china_cdn_id": "lp1NrLZnCUM.mp4"
              }
            },
            {
              "id": 268055,
              "key": "40760579-17ee-4a55-a406-f823144a3b1f",
              "title": "",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What are the width, height and depth for padding = 'same', stride = 1?\n\nEnter your answers in the format \"width, height, depth\"",
                "matchers": [
                  {
                    "expression": "\"*28,\\s*28,\\s*8\"*"
                  }
                ]
              }
            },
            {
              "id": 268057,
              "key": "8990692b-866c-46c4-b6f1-257f4df33ce9",
              "title": "",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What are the width, height and depth for padding = 'valid', stride = 1?\n\nEnter your answers in the format \"width, height, depth\"",
                "matchers": [
                  {
                    "expression": "\"*26,\\s*26,\\s*8\"*"
                  }
                ]
              }
            },
            {
              "id": 268058,
              "key": "f62136ad-ba37-45d8-9dd0-a6c8c4a57f55",
              "title": "",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What are the width, height and depth for padding = 'valid', stride = 2?\n\nEnter your answers in the format \"width, height, depth\"",
                "matchers": [
                  {
                    "expression": "\"*13,\\s*13,\\s*8\"*"
                  }
                ]
              }
            },
            {
              "id": 268059,
              "key": "285bd011-2922-4c29-b9a5-1d743c23855a",
              "title": "Feature-Map-Sizes-Solution",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "W4xtf8LTz1c",
                "china_cdn_id": "W4xtf8LTz1c.mp4"
              }
            }
          ]
        },
        {
          "id": 268002,
          "key": "3638458d-0576-4590-95cf-1cfb502adcad",
          "title": "Convolutions continued",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 268003,
              "key": "d5576aaf-8a77-4013-a3c8-c2d5a9a2b8bc",
              "title": "Convolutions Cont.",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "Note, a \"Fully Connected\" layer is a standard, non convolutional layer, where all inputs are connected to all output neurons. This is also referred to as a \"dense\" layer, and is what we used in the previous two lessons.",
              "video": {
                "youtube_id": "utOv-BKI_vo",
                "china_cdn_id": "utOv-BKI_vo.mp4"
              }
            }
          ]
        },
        {
          "id": 217097,
          "key": "89f26417-d3ff-45c1-bccc-4e7913e9e135",
          "title": "Parameters",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217099,
              "key": "a21de279-98c2-4765-92a9-9424448f44dc",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Parameter Sharing",
              "instructor_notes": ""
            },
            {
              "id": 217100,
              "key": "eb700544-b583-4e66-af70-0ef0564e4cf9",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58377f77_vlcsnap-2016-11-24-16h01m35s262/vlcsnap-2016-11-24-16h01m35s262.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/eb700544-b583-4e66-af70-0ef0564e4cf9",
              "caption": "The weights, `w`, are shared across patches for a given layer in a CNN to detect the cat above regardless of where in the image it is located.",
              "alt": null,
              "width": 1280,
              "height": 738,
              "instructor_notes": null
            },
            {
              "id": 217101,
              "key": "96306fe2-015e-4c76-8eeb-096857f90fc0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "When we are trying to classify a picture of a cat, we don’t care where in the image a cat is. If it’s in the top left or the bottom right, it’s still a cat in our eyes. We would like our CNNs to also possess this ability known as translation invariance. How can we achieve this?\n\nAs we saw earlier, the classification of a given patch in an image is determined by the weights and biases corresponding to that patch.\n\nIf we want a cat that’s in the top left patch to be classified in the same way as a cat in the bottom right patch, we need the weights and biases corresponding to those patches to be the same, so that they are classified the same way. \n\nThis is exactly what we do in CNNs. The weights  and biases we learn for a given output layer are shared across all patches in a given input layer. Note that as we increase the depth of our filter, the number of weights and biases we have to learn still increases, as the weights aren't shared across the output channels.\n\nThere’s an additional benefit to sharing our parameters. If we did not reuse the same weights across all patches, we would have to learn new parameters for every single patch and hidden layer neuron pair. This does not scale well, especially for higher fidelity images. Thus, sharing parameters not only helps us with translation invariance, but also gives us a smaller, more scalable model.",
              "instructor_notes": ""
            },
            {
              "id": 217102,
              "key": "da4dd3a4-b0f8-4d3d-bd7d-9ac43e4d1ed3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Padding\n",
              "instructor_notes": ""
            },
            {
              "id": 217111,
              "key": "4a227cdd-d0f5-4a09-8765-da4238760420",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/5837d4d5_screen-shot-2016-11-24-at-10.05.37-pm/screen-shot-2016-11-24-at-10.05.37-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/4a227cdd-d0f5-4a09-8765-da4238760420",
              "caption": "A `5x5` grid with a `3x3` filter. Source: Andrej Karpathy.",
              "alt": null,
              "width": 278,
              "height": 278,
              "instructor_notes": null
            },
            {
              "id": 385829,
              "key": "6076d518-e1d2-48e0-9c39-f79ecf0f160b",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "Let's say we have a `5x5` grid (as shown above) and a filter of size `3x3` with a stride of `1`. What's the width and height of the next layer? ",
                "answers": [
                  {
                    "id": "a1504263364274",
                    "text": "5x5",
                    "is_correct": false
                  },
                  {
                    "id": "a1504263389976",
                    "text": "2x2",
                    "is_correct": false
                  },
                  {
                    "id": "a1504263392310",
                    "text": "3x3",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 385828,
              "key": "c0dfa72d-7269-4e8a-85b2-5c9acd714199",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "As we can see, the width and height of each subsequent layer decreases in the above scheme.\n\nIn an ideal world, we'd be able to maintain the same width and height across layers so that we can continue to add layers without worrying about the dimensionality shrinking and so that we have consistency. How might we achieve this? One way is to simply add a border of `0`s to our original `5x5` image. You can see what this looks like in the below image.",
              "instructor_notes": ""
            },
            {
              "id": 217112,
              "key": "ed5e3c84-a67f-4af1-9c7d-3044cb5f9497",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/5837d4ee_screen-shot-2016-11-24-at-10.05.46-pm/screen-shot-2016-11-24-at-10.05.46-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/ed5e3c84-a67f-4af1-9c7d-3044cb5f9497",
              "caption": "The same grid with `0` padding. Source: Andrej Karpathy.",
              "alt": null,
              "width": 388,
              "height": 390,
              "instructor_notes": null
            },
            {
              "id": 217104,
              "key": "5b032630-e022-4f5d-8abf-bc16bb5f6031",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": " This would expand our original image to a `7x7`. With this, we now see how our next layer's size is again a `5x5`, keeping our dimensionality consistent.",
              "instructor_notes": ""
            },
            {
              "id": 217113,
              "key": "c6599167-dcb6-4fdd-bfb4-917ede0d22a6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Dimensionality\n\nFrom what we've learned so far, how can we calculate the number of neurons of each layer in our CNN? \n\nGiven:\n* our input layer has a width of `W` and a height of `H`\n* our convolutional layer has a filter size `F`\n* we have a stride of `S`\n* a padding of `P`\n* and the number of filters `K`, \n\nthe following formula gives us the width of the next layer: ```W_out =[ (W−F+2P)/S] + 1```.  \n\nThe output height would be ```H_out = [(H-F+2P)/S] + 1```. \n\nAnd the output depth would be equal to the number of filters `D_out = K`. \n\nThe output volume would be ```W_out * H_out * D_out```.\n\nKnowing the dimensionality of each additional layer helps us understand how large our model is and how our decisions around filter size and stride affect the size of our network.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217380,
          "key": "4f028128-6c6a-41e1-80cd-58f54189615d",
          "title": "Quiz: Convolution Output Shape",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217381,
              "key": "c0dac984-82f5-4c72-b07f-a8b1bc81140e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Introduction\n\nFor the next few quizzes we'll test your understanding of the dimensions in CNNs. Understanding dimensions will help you make accurate tradeoffs between model size and performance. As you'll see, some parameters have a much bigger impact on model size than others.\n\n### Setup\n\nH = height, W = width, D = depth\n\n* We have an input of shape 32x32x3 (HxWxD)\n* 20 filters of shape 8x8x3 (HxWxD)\n* A stride of 2 for both the height and width (S)\n* With padding of size 1 (P)\n\nRecall the formula for calculating the new height or width:\n\n```\nnew_height = (input_height - filter_height + 2 * P)/S + 1\nnew_width = (input_width - filter_width + 2 * P)/S + 1\n```",
              "instructor_notes": ""
            },
            {
              "id": 217382,
              "key": "627fa396-81d9-47f2-81bc-63f049bdf72f",
              "title": "Convolutional Layer Output Shape",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What's the shape of the output? \n\nThe answer format is **HxWxD**, so if you think the new height is 9, new width is 9, and new depth is 5, then type 9x9x5.",
                "matchers": [
                  {
                    "expression": "14x14x20"
                  },
                  {
                    "expression": "[0-9]+x[0-9]+x20"
                  },
                  {
                    "expression": "14x14x[0-9]+"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 217383,
          "key": "d0db3cab-ad70-46ec-9614-4dfc27dfc865",
          "title": "Solution: Convolution Output Shape",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217384,
              "key": "3b780879-3bb2-4eba-9441-8b91f795a7be",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nThe answer is **14x14x20**.\n\nWe can get the new height and width with the formula resulting in:\n\n```\n(32 - 8 + 2 * 1)/2 + 1 = 14\n(32 - 8 + 2 * 1)/2 + 1 = 14\n```\n\nThe new depth is equal to the number of filters, which is 20.",
              "instructor_notes": ""
            },
            {
              "id": 219800,
              "key": "21ccd211-4298-4bd8-9be7-2d44e23557ad",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "This would correspond to the following code:\n\n```python\ninput = tf.placeholder(tf.float32, (None, 32, 32, 3))\nfilter_weights = tf.Variable(tf.truncated_normal((8, 8, 3, 20))) # (height, width, input_depth, output_depth)\nfilter_bias = tf.Variable(tf.zeros(20))\nstrides = [1, 2, 2, 1] # (batch, height, width, depth)\npadding = 'SAME'\nconv = tf.nn.conv2d(input, filter_weights, strides, padding) + filter_bias\n```\n\nNote the output shape of `conv` will be [1, 16, 16, 20]. It's 4D to account for batch size, but more importantly, it's not [1, 14, 14, 20]. This is because the padding algorithm TensorFlow uses is not exactly the same as the one above. An alternative algorithm is to switch `padding` from `'SAME'` to `'VALID'` which would result in an output shape of [1, 13, 13, 20]. If you're curious how padding works in TensorFlow, read [this document](https://www.tensorflow.org/api_docs/python/tf/nn/convolution).\n\nIn summary TensorFlow uses the following equation for 'SAME' vs 'VALID'\n\n**SAME Padding**, the output height and width are computed as:\n\n`out_height` = ceil(float(in_height) / float(strides[1]))\n\n`out_width` = ceil(float(in_width) / float(strides[2]))\n\n\n**VALID Padding**, the output height and width are computed as:\n\n`out_height` = ceil(float(in_height - filter_height + 1) / float(strides[1]))\n\n`out_width` = ceil(float(in_width - filter_width + 1) / float(strides[2]))",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217385,
          "key": "99df67c6-a4a1-4149-8271-be731155becc",
          "title": "Quiz: Number of Parameters",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217399,
              "key": "41c5e80b-82a4-45ed-8d96-55f222a3147e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We're now going to calculate the number of parameters of the convolutional layer. The answer from the last quiz will come into play here!\n\nBeing able to calculate the number of parameters in a neural network is useful since we want to have control over how much memory a neural network uses.\n\n### Setup\n\nH = height, W = width, D = depth\n* We have an input of shape 32x32x3 (HxWxD)\n* 20 filters of shape 8x8x3 (HxWxD)\n* A stride of 2 for both the height and width (S)\n* Zero padding of size 1 (P)\n\n### Output Layer\n* 14x14x20 (HxWxD)\n\n### Hint\nWithout parameter sharing, each neuron in the output layer must connect to each neuron in the filter. In addition, each neuron in the output layer must also connect to a single bias neuron.",
              "instructor_notes": ""
            },
            {
              "id": 217401,
              "key": "489c1658-a8f6-41e2-850f-8a6cafb11691",
              "title": "Convolution Layer Parameters 1",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "How many parameters does the convolutional layer have (without parameter sharing)?\n",
                "matchers": [
                  {
                    "expression": "756560"
                  },
                  {
                    "expression": "752640"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 217386,
          "key": "5377ffff-a041-41cb-97a0-f86c398a76cb",
          "title": "Solution: Number of Parameters",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217402,
              "key": "eefa9e47-f9ab-435a-b00a-0c8c8abcca1e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nThere are ```756560``` total parameters. That's a HUGE amount! Here's how we calculate it:\n\n```(8 * 8 * 3 + 1) * (14 * 14 * 20) = 756560```\n\n```8 * 8 * 3``` is the number of weights, we add ```1``` for the bias. Remember, each weight is assigned to every single part of the output (```14 * 14 * 20```). So we multiply these two numbers together and we get the final answer.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217387,
          "key": "f1bd5dcc-5e97-48ef-bd74-01d0c7c620e7",
          "title": "Quiz: Parameter Sharing",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 218040,
              "key": "0f6aeb7c-d369-4f0a-94f9-a7b90d8f9da2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now we'd like you to calculate the number of parameters in the convolutional layer, if every neuron in the output layer shares its parameters with every other neuron in its same channel.\n\nThis is the number of parameters actually used in a convolution layer ([`tf.nn.conv2d()`](https://www.tensorflow.org/api_docs/python/tf/nn/conv2d)).\n\n### Setup\n\nH = height, W = width, D = depth\n* We have an input of shape 32x32x3 (HxWxD)\n* 20 filters of shape 8x8x3 (HxWxD)\n* A stride of 2 for both the height and width (S)\n* Zero padding of size 1 (P)\n\n### Output Layer\n* 14x14x20 (HxWxD)\n\n### Hint\nWith parameter sharing, each neuron in an output channel shares its weights with every other neuron in that channel. So the number of parameters is equal to the number of neurons in the filter, plus a bias neuron, all multiplied by the number of channels in the output layer.",
              "instructor_notes": ""
            },
            {
              "id": 217403,
              "key": "9046a2fc-5165-4e7e-bd27-4eccdeb25574",
              "title": "Convolution Layer Parameters 2",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "How many parameters does the convolution layer have (with parameter sharing)?\n",
                "matchers": [
                  {
                    "expression": "3860"
                  },
                  {
                    "expression": "3840"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 217388,
          "key": "ae7e9d37-9e45-4143-a90b-93f6a689d624",
          "title": "Solution: Parameter Sharing",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217404,
              "key": "fcadba6b-b7b3-4c39-877c-ad258cfffc65",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nThere are ```3860``` total parameters. That's 196 times fewer parameters! Here's how the answer is calculated:\n\n```(8 * 8 * 3 + 1) * 20 = 3840 + 20 = 3860```\n\nThat's ```3840``` weights and ```20``` biases. This should look similar to the answer from the previous quiz. The difference being it's just ```20``` instead of (```14 * 14 * 20```). Remember, with weight sharing we use the same filter for an entire depth slice. Because of this we can get rid of ```14 * 14``` and be left with only ```20```.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 216770,
          "key": "05f91f07-6de6-4b6b-b989-6112802e09a4",
          "title": "Visualizing CNNs",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 216771,
              "key": "52808599-4650-4298-9e85-94b7b0f0259e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Visualizing CNNs\n\nLet’s look at an example CNN to see how it works in action. \n\nThe CNN we will look at is trained on ImageNet as described in [this paper](https://arxiv.org/abs/1311.2901) by Zeiler and Fergus. In the images below (from the same paper), we’ll see *what* each layer in this network detects and see *how* each layer detects more and more complex ideas.",
              "instructor_notes": ""
            },
            {
              "id": 217357,
              "key": "6fc7e5ca-d9b9-4e08-b954-381bc83a9a3b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Layer 1",
              "instructor_notes": ""
            },
            {
              "id": 217362,
              "key": "74806463-4520-49f3-8ca7-5a4286d556bd",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/583cbd42_layer-1-grid/layer-1-grid.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/74806463-4520-49f3-8ca7-5a4286d556bd",
              "caption": "Example patterns that cause activations in the first layer of the network. These range from simple diagonal lines (top left) to green blobs (bottom middle).",
              "alt": null,
              "width": 165,
              "height": 171,
              "instructor_notes": null
            },
            {
              "id": 216773,
              "key": "8023f628-9a6c-4c3a-a35a-6a6bb15a6138",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The images above are from Matthew Zeiler and Rob Fergus' [deep visualization toolbox](https://www.youtube.com/watch?v=ghEmQSxT6tw), which lets us visualize what each layer in a CNN focuses on. \n\nEach image in the above grid represents a pattern that causes the neurons in the first layer to activate - in other words, they are patterns that the first layer recognizes. The top left image shows a -45 degree line, while the middle top square shows a +45 degree line. These squares are shown below again for reference.",
              "instructor_notes": ""
            },
            {
              "id": 217355,
              "key": "c672f583-4c23-462b-8493-12ad6e5c875a",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/583cbba2_diagonal-line-1/diagonal-line-1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/c672f583-4c23-462b-8493-12ad6e5c875a",
              "caption": "As visualized here, the first layer of the CNN can recognize -45 degree lines.",
              "alt": null,
              "width": 55,
              "height": 53,
              "instructor_notes": null
            },
            {
              "id": 217356,
              "key": "dbaefec0-d84a-4826-b492-73d3ecaf9c2e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/583cbc02_diagonal-line-2/diagonal-line-2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/dbaefec0-d84a-4826-b492-73d3ecaf9c2e",
              "caption": "The first layer of the CNN is also able to recognize +45 degree lines, like the one above.",
              "alt": null,
              "width": 58,
              "height": 58,
              "instructor_notes": null
            },
            {
              "id": 217352,
              "key": "49684c1a-2f95-4eb8-ab63-4cc9eaced27c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Let's now see some example images that cause such activations. The below grid of images all activated the -45 degree line. Notice how they are all selected despite the fact that they have different colors, gradients, and patterns.",
              "instructor_notes": ""
            },
            {
              "id": 217354,
              "key": "852407da-0ff5-42ee-ad7e-7c3ab89dc678",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/583cbace_grid-layer-1/grid-layer-1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/852407da-0ff5-42ee-ad7e-7c3ab89dc678",
              "caption": "Example patches that activate the -45 degree line detector in the first layer.",
              "alt": null,
              "width": 146,
              "height": 143,
              "instructor_notes": null
            },
            {
              "id": 217363,
              "key": "e156b87f-08c3-42e8-b605-a332773fcba9",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So, the first layer of our CNN clearly picks out very simple shapes and patterns like lines and blobs.",
              "instructor_notes": ""
            },
            {
              "id": 217358,
              "key": "bd73aff1-7074-41ef-ab3a-3f9585922201",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Layer 2",
              "instructor_notes": ""
            },
            {
              "id": 216774,
              "key": "f853c751-8de8-4ecc-aa38-716c391c8456",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/583780f3_screen-shot-2016-11-24-at-12.09.02-pm/screen-shot-2016-11-24-at-12.09.02-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/f853c751-8de8-4ecc-aa38-716c391c8456",
              "caption": "A visualization of the second layer in the CNN. Notice how we are picking up more complex ideas like circles and stripes. The gray grid on the left represents how this layer of the CNN activates (or \"what it sees\") based on the corresponding images from the grid on the right.",
              "alt": null,
              "width": 1888,
              "height": 922,
              "instructor_notes": null
            },
            {
              "id": 216776,
              "key": "d1b7d85b-a882-4e30-a125-bef3ae8c253f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The second layer of the CNN  captures complex ideas. \n\nAs you see in the image above, the second layer of the CNN recognizes circles (second row, second column), stripes (first row, second column), and rectangles (bottom right). \n\n**The CNN learns to do this on its own.** There is no special instruction for the CNN to focus on more complex objects in deeper layers. That's just how it normally works out when you feed training data into a CNN.\n",
              "instructor_notes": ""
            },
            {
              "id": 217359,
              "key": "e1132dc0-f466-4255-bce6-64692c509748",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Layer 3",
              "instructor_notes": ""
            },
            {
              "id": 216778,
              "key": "3dcf0442-25fb-41c4-8ec7-b9316ba6d4e4",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/5837811f_screen-shot-2016-11-24-at-12.09.24-pm/screen-shot-2016-11-24-at-12.09.24-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/3dcf0442-25fb-41c4-8ec7-b9316ba6d4e4",
              "caption": "A visualization of the third layer in the CNN. The gray grid on the left represents how this layer of the CNN activates (or \"what it sees\") based on the corresponding images from the grid on the right.",
              "alt": null,
              "width": 2294,
              "height": 848,
              "instructor_notes": null
            },
            {
              "id": 216779,
              "key": "660e77d0-dfd2-4591-8a92-e0bd1cdbf8c2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The third layer picks out complex combinations of features from the second layer. These include things like grids, and honeycombs (top left), wheels (second row, second column), and even faces (third row, third column).",
              "instructor_notes": ""
            },
            {
              "id": 217361,
              "key": "6fe9e320-7e75-4d29-a5cf-f328d45992ab",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We'll skip layer 4, which continues this progression, and jump right to the fifth and final layer of this CNN.\n\n### Layer 5\n\n",
              "instructor_notes": ""
            },
            {
              "id": 216780,
              "key": "8bef3d7b-8e2d-41af-a157-f64aa24afbc5",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/58378151_screen-shot-2016-11-24-at-12.08.11-pm/screen-shot-2016-11-24-at-12.08.11-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/8bef3d7b-8e2d-41af-a157-f64aa24afbc5",
              "caption": "A visualization of the fifth and final layer of the CNN. The gray grid on the left represents how this layer of the CNN activates (or \"what it sees\") based on the corresponding images from the grid on the right.",
              "alt": null,
              "width": 1198,
              "height": 1484,
              "instructor_notes": null
            },
            {
              "id": 216781,
              "key": "516aca63-ce7a-4398-8fc3-b0bbd386d0be",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The last layer picks out the highest order ideas that we care about for classification, like dog faces, bird faces, and bicycles. \n\n### On to TensorFlow\n\nThis concludes our high-level discussion of Convolutional Neural Networks. \n\nNext you'll practice actually building these networks in TensorFlow.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 205139,
          "key": "0377449f-ce0f-436b-8e11-2cdfefe20995",
          "title": "TensorFlow Convolution Layer",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 205143,
              "key": "4da877bc-4217-47ef-83d7-b524fe237df7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### TensorFlow Convolution Layer",
              "instructor_notes": ""
            },
            {
              "id": 205141,
              "key": "bfe3d97a-12bd-448b-ad0b-f1c3cd4bb233",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Let's examine how to implement a CNN in TensorFlow.\n\nTensorFlow provides the [`tf.nn.conv2d()`](https://www.tensorflow.org/api_docs/python/tf/nn/conv2d) and [`tf.nn.bias_add()`](https://www.tensorflow.org/api_docs/python/tf/nn/bias_add) functions to create your own convolutional layers.\n```python\n# Output depth\nk_output = 64\n\n# Image Properties\nimage_width = 10\nimage_height = 10\ncolor_channels = 3\n\n# Convolution filter\nfilter_size_width = 5\nfilter_size_height = 5\n\n# Input/Image\ninput = tf.placeholder(\n    tf.float32,\n    shape=[None, image_height, image_width, color_channels])\n\n# Weight and bias\nweight = tf.Variable(tf.truncated_normal(\n    [filter_size_height, filter_size_width, color_channels, k_output]))\nbias = tf.Variable(tf.zeros(k_output))\n\n# Apply Convolution\nconv_layer = tf.nn.conv2d(input, weight, strides=[1, 2, 2, 1], padding='SAME')\n# Add bias\nconv_layer = tf.nn.bias_add(conv_layer, bias)\n# Apply activation function\nconv_layer = tf.nn.relu(conv_layer)\n```\nThe code above uses the [`tf.nn.conv2d()`](https://www.tensorflow.org/api_docs/python/tf/nn/conv2d) function to compute the convolution with `weight` as the filter and `[1, 2, 2, 1]` for the strides.  TensorFlow uses a stride for each `input` dimension, `[batch, input_height, input_width, input_channels]`.  We are generally always going to set the stride for `batch` and `input_channels` (i.e. the first and fourth element in the `strides` array) to be `1`.\n\nYou'll focus on changing `input_height` and  `input_width` while setting `batch` and `input_channels` to 1.  The `input_height` and `input_width` strides are for striding the filter over `input`. This example code uses a stride of 2 with 5x5 filter over `input`.\n\nThe [`tf.nn.bias_add()`](https://www.tensorflow.org/api_docs/python/tf/nn/bias_add) function adds a 1-d bias to the last dimension in a matrix.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 268006,
          "key": "c31aebd3-e36d-4d57-b6f1-646aebe52a51",
          "title": "Explore The Design Space",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 268007,
              "key": "567cc4c1-3ecb-41dd-a2dc-908cb1245dea",
              "title": "Explore the Design Space",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "FG7M9tWH2nQ",
                "china_cdn_id": "FG7M9tWH2nQ.mp4"
              }
            }
          ]
        },
        {
          "id": 205338,
          "key": "245c6fd1-efec-4c37-8a1f-96e7d055e845",
          "title": "TensorFlow Max Pooling",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 205341,
              "key": "f2299bd5-55f6-4c15-b499-80d023548bb1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# TensorFlow Max Pooling",
              "instructor_notes": ""
            },
            {
              "id": 206356,
              "key": "98f32c32-aa1c-4b00-8497-052506fcf9ce",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/582aac09_max-pooling/max-pooling.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/98f32c32-aa1c-4b00-8497-052506fcf9ce",
              "caption": "By Aphex34 (Own work) [CC BY-SA 4.0 (http://creativecommons.org/licenses/by-sa/4.0)], via Wikimedia Commons",
              "alt": null,
              "width": 570,
              "height": 330,
              "instructor_notes": null
            },
            {
              "id": 205340,
              "key": "4c3cf7c8-6af9-4b20-b9e7-c3493d1b1633",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The image above is an example of [max pooling](https://en.wikipedia.org/wiki/Convolutional_neural_network#Pooling_layer) with a 2x2 filter and stride of 2.  The four 2x2 colors represent each time the filter was applied to find the maximum value.  \n\nFor example, `[[1, 0], [4, 6]]` becomes `6`, because `6` is the maximum value in this set. Similarly, `[[2, 3], [6, 8]]` becomes `8`.\n\nConceptually, the benefit of the max pooling operation is to reduce the size of the input, and allow the neural network to focus on only the most important elements. Max pooling does this by only retaining the maximum value for each filtered area, and removing the remaining values.\n\nTensorFlow provides the  [`tf.nn.max_pool()`](https://www.tensorflow.org/api_docs/python/tf/nn/max_pool) function to apply [max pooling](https://en.wikipedia.org/wiki/Convolutional_neural_network#Pooling_layer) to your convolutional layers.\n```python\n...\nconv_layer = tf.nn.conv2d(input, weight, strides=[1, 2, 2, 1], padding='SAME')\nconv_layer = tf.nn.bias_add(conv_layer, bias)\nconv_layer = tf.nn.relu(conv_layer)\n# Apply Max Pooling\nconv_layer = tf.nn.max_pool(\n    conv_layer,\n    ksize=[1, 2, 2, 1],\n    strides=[1, 2, 2, 1],\n    padding='SAME')\n```\nThe [`tf.nn.max_pool()`](https://www.tensorflow.org/api_docs/python/tf/nn/max_pool) function performs max pooling with the `ksize` parameter as the size of the filter and the `strides` parameter as the length of the stride. 2x2 filters with a stride of 2x2 are common in practice.\n\nThe `ksize` and `strides` parameters are structured as 4-element lists, with each element corresponding to a dimension of the input tensor (`[batch, height, width, channels]`). For both `ksize` and `strides`, the batch and channel dimensions are typically set to `1`.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217389,
          "key": "0ffba003-b681-4d56-9d6d-e5dd13cb99a0",
          "title": "Quiz: Pooling Intuition",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217405,
              "key": "321244bf-0956-4630-bfc0-4067c874f57f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The next few quizzes will test your understanding of **pooling layers**.",
              "instructor_notes": ""
            },
            {
              "id": 217406,
              "key": "3a4aa5e4-6766-4015-805b-290b60c9da2d",
              "title": "What Does A Pooling Layer Do?",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "A pooling layer is generally used to ...",
                "answers": [
                  {
                    "id": "a1480388522381",
                    "text": "Increase the size of the output",
                    "is_correct": false
                  },
                  {
                    "id": "a1480388532905",
                    "text": "Decrease the size of the output",
                    "is_correct": true
                  },
                  {
                    "id": "a1480388533875",
                    "text": "Prevent overfitting",
                    "is_correct": true
                  },
                  {
                    "id": "a1480388534602",
                    "text": "Gain information",
                    "is_correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 217395,
          "key": "21a70643-4262-45a2-9450-2273bc939d45",
          "title": "Solution: Pooling Intuition",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217407,
              "key": "06176f36-cbd8-4958-a9c6-7785b09e3872",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nThe correct answer is **decrease the size of the output** and **prevent overfitting**. Preventing overfitting is a consequence of reducing the output size, which in turn, reduces the number of parameters in future layers.",
              "instructor_notes": ""
            },
            {
              "id": 217408,
              "key": "08eb7a93-1b1e-4b6b-8b6a-13317370b08d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Recently, pooling layers have fallen out of favor. Some reasons are:\n\n* Recent datasets are so big and complex we're more concerned about underfitting.\n* Dropout is a much better regularizer.\n* Pooling results in a loss of information. Think about the max pooling operation as an example. We only keep the largest of *n* numbers, thereby disregarding *n-1* numbers completely.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217391,
          "key": "afa4f4ce-47d6-41eb-9cf4-773ad2ce943f",
          "title": "Quiz: Pooling Mechanics",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217409,
              "key": "25bac018-539c-4348-b3e7-e52779748bd7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Setup\n\nH = height, W = width, D = depth\n\n* We have an input of shape 4x4x5 (HxWxD)\n* Filter of shape 2x2 (HxW) \n* A stride of 2 for both the height and width (S)\n\nRecall the formula for calculating the new height or width:\n\n```\nnew_height = (input_height - filter_height)/S + 1\nnew_width = (input_width - filter_width)/S + 1\n```\n\nNOTE: For a pooling layer the output depth is the same as the input depth. Additionally, the pooling operation is applied individually for each depth slice.\n\nThe image below gives an example of how a max pooling layer works. In this case, the max pooling filter has a shape of 2x2. As the max pooling filter slides across the input layer, the filter will output the maximum value of the 2x2 square. ",
              "instructor_notes": ""
            },
            {
              "id": 267040,
              "key": "65576a90-5005-4225-827e-c1cc05d647ba",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/February/58a5fe3e_convolutionalnetworksquiz/convolutionalnetworksquiz.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/65576a90-5005-4225-827e-c1cc05d647ba",
              "caption": "",
              "alt": null,
              "width": 8800,
              "height": 4950,
              "instructor_notes": null
            },
            {
              "id": 217410,
              "key": "a3dbe414-8a90-411d-8e66-2b623fd61488",
              "title": "Pooling Layer Output Shape",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What's the shape of the output? Format is **HxWxD**.",
                "matchers": [
                  {
                    "expression": "2x2x5"
                  },
                  {
                    "expression": "2x2x[0-9]+"
                  },
                  {
                    "expression": "[0-9]+x[0-9]+x5"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 217396,
          "key": "2f6cb4b3-05e4-4500-9325-a0f4a35ba671",
          "title": "Solution: Pooling Mechanics",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217411,
              "key": "c46b2e29-e6f8-4239-a0e6-1850b5b177ee",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nThe answer is **2x2x5**. Here's how it's calculated using the formula:\n\n```\n(4 - 2)/2 + 1 = 2\n(4 - 2)/2 + 1 = 2\n```\n\nThe depth stays the same.",
              "instructor_notes": ""
            },
            {
              "id": 219801,
              "key": "fb911a5e-a057-457b-a0de-92e8f5d0e38f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Here's the corresponding code:\n\n```python\ninput = tf.placeholder(tf.float32, (None, 4, 4, 5))\nfilter_shape = [1, 2, 2, 1]\nstrides = [1, 2, 2, 1]\npadding = 'VALID'\npool = tf.nn.max_pool(input, filter_shape, strides, padding)\n```\n\nThe output shape of `pool` will be [1, 2, 2, 5], even if `padding` is changed to `'SAME'`.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217392,
          "key": "2b9fcd00-c591-4296-82f3-9f48f19c0291",
          "title": "Quiz: Pooling Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217412,
              "key": "3476105c-040b-4b04-899b-9d0f3a22fb83",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Great, now let's practice doing some pooling operations manually.",
              "instructor_notes": ""
            },
            {
              "id": 217413,
              "key": "ef0e7172-d0c0-444e-b20d-04eef73c1750",
              "title": "Max Pooling",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What's the result of a **max pooling** operation on the input:\n\n```\n[[[0, 1, 0.5, 10],\n   [2, 2.5, 1, -8],\n   [4, 0, 5, 6],\n   [15, 1, 2, 3]]]\n```\nAssume the filter is 2x2 and the stride is 2 for both height and width. The output shape is 2x2x1.\n\nThe answering format will be 4 numbers, each separated by a comma, such as: `1,2,3,4`.\n\n**Work from the top left to the bottom right**",
                "matchers": [
                  {
                    "expression": "[\\s]*2.5(0*|)[\\s]*,[\\s]*10(\\.0*|)[\\s]*,[\\s]*15(\\.0*|)[\\s]*,[\\s]*6(\\.0*|)"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 217397,
          "key": "596bb21b-5831-4418-bf89-6593672475d5",
          "title": "Solution: Pooling Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217414,
              "key": "81fc9003-5e75-4111-8e67-cdde5d067c68",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nThe correct answer is `2.5,10,15,6`. We start with the four numbers in the top left corner. Then we work left-to-right and top-to-bottom, moving 2 units each time.\n\n```\nmax(0, 1, 2, 2.5) = 2.5\nmax(0.5, 10, 1, -8) = 10\nmax(4, 0, 15, 1) = 15\nmax(5, 6, 2, 3) = 6\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217394,
          "key": "985699e0-865c-41cb-af18-5a7f28a01676",
          "title": "Quiz: Average Pooling",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217416,
              "key": "2f5c3613-26a8-45a4-ba2d-d9b204cb38bf",
              "title": "Mean Pooling",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "question": {
                "prompt": "What's the result of a **average (or mean) pooling**?\n\n```\n[[[0, 1, 0.5, 10],\n   [2, 2.5, 1, -8],\n   [4, 0, 5, 6],\n   [15, 1, 2, 3]]]\n```\nAssume the filter is 2x2 and the stride is 2 for both height and width. The output shape is 2x2x1.\n\nThe answering format will be 4 numbers, each separated by a comma, such as: 1,2,3,4.\n\n**Answer to 3 decimal places. Work from the top left to the bottom right**",
                "matchers": [
                  {
                    "expression": "[\\s]*1.375(0*|)[\\s]*,[\\s]*0?\\.875(0*|)[\\s]*,[\\s]*5(\\.0*|)[\\s]*,[\\s]*4(\\.0*|)"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 217398,
          "key": "40990c7b-34b6-4600-b6ea-771f167271a0",
          "title": "Solution: Average Pooling",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217415,
              "key": "7ccb51b5-5e2d-44b5-aab1-b41549f5a855",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nThe correct answer is `1.375,0.875,5,4`. We start with the four numbers in the top left corner. Then we work left-to-right and top-to-bottom, moving 2 units each time.\n\n```\nmean(0, 1, 2, 2.5) = 1.375\nmean(0.5, 10, 1, -8) = 0.875\nmean(4, 0, 15, 1) = 5\nmean(5, 6, 2, 3) = 4\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 268009,
          "key": "d4c64a6a-254b-4c7a-85f8-958047b040d7",
          "title": "1x1 Convolutions",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 268010,
              "key": "4ac9d501-014e-419b-b8cd-fb6ff6f49ac3",
              "title": "1x1 Convolutions",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Zmzgerm6SjA",
                "china_cdn_id": "Zmzgerm6SjA.mp4"
              }
            }
          ]
        },
        {
          "id": 268011,
          "key": "e69984aa-9b9d-4260-9265-d5833db3ef5b",
          "title": "Inception Module",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 268012,
              "key": "65a832c6-e35e-4e6d-9ff8-ea0790b729f3",
              "title": "Inception Module",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "SlTm03bEOxA",
                "china_cdn_id": "SlTm03bEOxA.mp4"
              }
            }
          ]
        },
        {
          "id": 199874,
          "key": "afe0660b-a035-499b-9441-737d601e19df",
          "title": "Convolutional Network in TensorFlow",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 199875,
              "key": "d66ad4e0-b777-45bf-aef4-5a525c10ac57",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Convolutional Network in TensorFlow\nIt's time to walk through an example Convolutional Neural Network (CNN) in TensorFlow. \n\nThe structure of this network follows the classic structure of CNNs, which is a mix of convolutional layers and max pooling, followed by fully-connected layers.\n\nThe code you'll be looking at is similar to what you saw in the segment on **Deep Neural Network in TensorFlow** in the previous lesson, except we restructured the architecture of this network as a CNN. \n\nJust like in that segment, here you'll study the line-by-line breakdown of the code. If you want, you can even [download the code](https://d17h27t6h515a5.cloudfront.net/topher/2017/February/58a61ca1_cnn/cnn.zip) and run it yourself.\n\nThanks to [Aymeric Damien](https://github.com/aymericdamien/TensorFlow-Examples) for providing the original TensorFlow model on which this segment is based.\n\nTime to dive in!\n\n### Dataset\nYou've seen this section of code from previous lessons.  Here we're importing the MNIST dataset and using a convenient TensorFlow function to batch, scale, and One-Hot encode the data.\n```python\nfrom tensorflow.examples.tutorials.mnist import input_data\nmnist = input_data.read_data_sets(\".\", one_hot=True, reshape=False)\n\nimport tensorflow as tf\n\n# Parameters\nlearning_rate = 0.00001\nepochs = 10\nbatch_size = 128\n\n# Number of samples to calculate validation and accuracy\n# Decrease this if you're running out of memory to calculate accuracy\ntest_valid_size = 256\n\n# Network Parameters\nn_classes = 10  # MNIST total classes (0-9 digits)\ndropout = 0.75  # Dropout, probability to keep units\n```\n\n### Weights and Biases\n```python\n# Store layers weight & bias\nweights = {\n    'wc1': tf.Variable(tf.random_normal([5, 5, 1, 32])),\n    'wc2': tf.Variable(tf.random_normal([5, 5, 32, 64])),\n    'wd1': tf.Variable(tf.random_normal([7*7*64, 1024])),\n    'out': tf.Variable(tf.random_normal([1024, n_classes]))}\n\nbiases = {\n    'bc1': tf.Variable(tf.random_normal([32])),\n    'bc2': tf.Variable(tf.random_normal([64])),\n    'bd1': tf.Variable(tf.random_normal([1024])),\n    'out': tf.Variable(tf.random_normal([n_classes]))}\n```\n\n### Convolutions",
              "instructor_notes": ""
            },
            {
              "id": 199896,
              "key": "650c9365-f2f5-49fb-9f34-18cfa1551b97",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/581a58be_convolution-schematic/convolution-schematic.gif",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/650c9365-f2f5-49fb-9f34-18cfa1551b97",
              "caption": "Convolution with 3×3 Filter.  Source: http://deeplearning.stanford.edu/wiki/index.php/Feature_extraction_using_convolution",
              "alt": "",
              "width": 263,
              "height": 192,
              "instructor_notes": null
            },
            {
              "id": 199946,
              "key": "9b304089-1801-4de4-a89d-ef27ca48e65c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The above is an example of a [convolution](https://en.wikipedia.org/wiki/Convolution) with a 3x3 filter and a stride of 1 being applied to data with a range of 0 to 1.  The convolution for each 3x3 section is calculated against the weight, `[[1, 0, 1], [0, 1, 0], [1, 0, 1]]`, then a bias is added to create the convolved feature on the right.  In this case, the bias is zero.  In TensorFlow, this is all done using [`tf.nn.conv2d()`](https://www.tensorflow.org/api_docs/python/tf/nn/conv2d) and [`tf.nn.bias_add()`](https://www.tensorflow.org/api_docs/python/tf/nn/bias_add).",
              "instructor_notes": ""
            },
            {
              "id": 199897,
              "key": "c2092db1-860d-4c31-95b6-9c583900f482",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```python\ndef conv2d(x, W, b, strides=1):\n    x = tf.nn.conv2d(x, W, strides=[1, strides, strides, 1], padding='SAME')\n    x = tf.nn.bias_add(x, b)\n    return tf.nn.relu(x)\n```\nThe [`tf.nn.conv2d()`](https://www.tensorflow.org/api_docs/python/tf/nn/conv2d) function computes the convolution against weight `W` as shown above.\n\nIn TensorFlow, `strides` is an array of 4 elements;  the first element in this array indicates the stride for batch and last element indicates stride for features.  It's good practice to remove the batches or features you want to skip from the data set rather than use a stride to skip them.  You can always set the first and last element to 1 in `strides` in order to use all batches and features.\n\nThe middle two elements are the strides for height and width respectively.  I've mentioned stride as one number because you usually have a square stride where `height = width`.  When someone says they are using a stride of 3, they usually mean `tf.nn.conv2d(x, W, strides=[1, 3, 3, 1])`.\n\nTo make life easier, the code is using [`tf.nn.bias_add()`](https://www.tensorflow.org/api_docs/python/tf/nn/bias_add) to add the bias.  Using [`tf.add()`](https://www.tensorflow.org/api_docs/python/tf/add) doesn't work when the tensors aren't the same shape.\n### Max Pooling",
              "instructor_notes": ""
            },
            {
              "id": 199895,
              "key": "390a2f75-b195-4b24-9a54-045c78d6e894",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/581a57fe_maxpool/maxpool.jpeg",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/390a2f75-b195-4b24-9a54-045c78d6e894",
              "caption": "Max Pooling with 2x2 filter and stride of 2.  Source: http://cs231n.github.io/convolutional-networks/",
              "alt": null,
              "width": 787,
              "height": 368,
              "instructor_notes": null
            },
            {
              "id": 199947,
              "key": "73dbfd7e-0494-45a9-9406-d7cd6725531c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The above is an example of [max pooling](https://en.wikipedia.org/wiki/Convolutional_neural_network#Pooling_layer) with a 2x2 filter and stride of 2.  The left square is the input and the right square is the output.  The four 2x2 colors in input represents each time the filter was applied to create the max on the right side.  For example, `[[1, 1], [5, 6]]` becomes 6 and `[[3, 2], [1, 2]]` becomes 3. ",
              "instructor_notes": ""
            },
            {
              "id": 199898,
              "key": "d77a4a3b-a0be-44be-b864-b954e07ab405",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```python\ndef maxpool2d(x, k=2):\n    return tf.nn.max_pool(\n        x,\n        ksize=[1, k, k, 1],\n        strides=[1, k, k, 1],\n        padding='SAME')\n```\nThe [`tf.nn.max_pool()`](https://www.tensorflow.org/api_docs/python/tf/nn/max_pool) function does exactly what you would expect, it performs max pooling with the `ksize` parameter as the size of the filter.\n### Model",
              "instructor_notes": ""
            },
            {
              "id": 199926,
              "key": "eb8c480c-6d55-4e8a-b4a4-8850de3b1d7c",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2016/November/581a64b7_arch/arch.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/eb8c480c-6d55-4e8a-b4a4-8850de3b1d7c",
              "caption": "Image from Explore The Design Space video",
              "alt": null,
              "width": 2594,
              "height": 1312,
              "instructor_notes": null
            },
            {
              "id": 199927,
              "key": "017ad9bd-8411-447b-96c2-1188bcc3336c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the code below, we're creating 3 layers alternating between convolutions and max pooling followed by a fully connected and output layer.  The transformation of each layer to new dimensions are shown in the comments.  For example, the first layer shapes the images from 28x28x1 to 28x28x32 in the convolution step.  Then next step applies max pooling, turning each sample into 14x14x32.  All the layers are applied from `conv1` to `output`, producing 10 class predictions.\n```python\ndef conv_net(x, weights, biases, dropout):\n    # Layer 1 - 28*28*1 to 14*14*32\n    conv1 = conv2d(x, weights['wc1'], biases['bc1'])\n    conv1 = maxpool2d(conv1, k=2)\n\n    # Layer 2 - 14*14*32 to 7*7*64\n    conv2 = conv2d(conv1, weights['wc2'], biases['bc2'])\n    conv2 = maxpool2d(conv2, k=2)\n\n    # Fully connected layer - 7*7*64 to 1024\n    fc1 = tf.reshape(conv2, [-1, weights['wd1'].get_shape().as_list()[0]])\n    fc1 = tf.add(tf.matmul(fc1, weights['wd1']), biases['bd1'])\n    fc1 = tf.nn.relu(fc1)\n    fc1 = tf.nn.dropout(fc1, dropout)\n\n    # Output Layer - class prediction - 1024 to 10\n    out = tf.add(tf.matmul(fc1, weights['out']), biases['out'])\n    return out\n```\n\n### Session\nNow let's run it!\n```python\n# tf Graph input\nx = tf.placeholder(tf.float32, [None, 28, 28, 1])\ny = tf.placeholder(tf.float32, [None, n_classes])\nkeep_prob = tf.placeholder(tf.float32)\n\n# Model\nlogits = conv_net(x, weights, biases, keep_prob)\n\n# Define loss and optimizer\ncost = tf.reduce_mean(\\\n    tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y))\noptimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)\\\n    .minimize(cost)\n\n# Accuracy\ncorrect_pred = tf.equal(tf.argmax(logits, 1), tf.argmax(y, 1))\naccuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))\n\n# Initializing the variables\ninit = tf. global_variables_initializer()\n\n# Launch the graph\nwith tf.Session() as sess:\n    sess.run(init)\n\n    for epoch in range(epochs):\n        for batch in range(mnist.train.num_examples//batch_size):\n            batch_x, batch_y = mnist.train.next_batch(batch_size)\n            sess.run(optimizer, feed_dict={\n                x: batch_x,\n                y: batch_y,\n                keep_prob: dropout})\n\n            # Calculate batch loss and accuracy\n            loss = sess.run(cost, feed_dict={\n                x: batch_x,\n                y: batch_y,\n                keep_prob: 1.})\n            valid_acc = sess.run(accuracy, feed_dict={\n                x: mnist.validation.images[:test_valid_size],\n                y: mnist.validation.labels[:test_valid_size],\n                keep_prob: 1.})\n\n            print('Epoch {:>2}, Batch {:>3} -'\n                  'Loss: {:>10.4f} Validation Accuracy: {:.6f}'.format(\n                epoch + 1,\n                batch + 1,\n                loss,\n                valid_acc))\n\n    # Calculate Test Accuracy\n    test_acc = sess.run(accuracy, feed_dict={\n        x: mnist.test.images[:test_valid_size],\n        y: mnist.test.labels[:test_valid_size],\n        keep_prob: 1.})\n    print('Testing Accuracy: {}'.format(test_acc))\n```\nThat's it!  That is a CNN in TensorFlow.  Now that you've seen a CNN in TensorFlow, let's see if you can apply it on your own!",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217145,
          "key": "28e86e48-c796-4231-bac2-d9472af61d97",
          "title": "TensorFlow Convolution Layer",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217146,
              "key": "79af7a97-e82b-4029-8707-872982d6a69d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Using Convolution Layers in TensorFlow\n\nLet's now apply what we've learned to build real CNNs in TensorFlow. In the below exercise, you'll be asked to set up the dimensions of the Convolution filters, the weights, the biases. This is in many ways the trickiest part to using CNNs in TensorFlow. Once you have a sense of how to set up the dimensions of these attributes, applying CNNs will be far more straight forward.\n\n### Review\n\nYou should go over the TensorFlow documentation for [2D convolutions](https://www.tensorflow.org/api_guides/python/nn#Convolution). Most of the documentation is straightforward, except perhaps the `padding` argument. The padding might differ depending on whether you pass `'VALID'` or `'SAME'`.\n\nHere are a few more things worth reviewing:\n\n1. Introduction to TensorFlow -> [TensorFlow Variables](https://www.tensorflow.org/programmers_guide/variables).\n2. How to determine the dimensions of the output based on the input size and the filter size (shown below). You'll use this to determine what the size of your filter should be. \n   ```\n    new_height = (input_height - filter_height + 2 * P)/S + 1\n    new_width = (input_width - filter_width + 2 * P)/S + 1\n    ```\n\n### Instructions\n\n1. Finish off each `TODO` in the `conv2d` function.\n2. Setup the `strides`, `padding` and filter weight/bias (`F_w` and `F_b`) such that\nthe output shape is `(1, 2, 2, 3)`. Note that all of these except `strides` should be TensorFlow variables.",
              "instructor_notes": ""
            },
            {
              "id": 217147,
              "key": "b5cda012-86d3-4771-bd10-5b6358d08289",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "instruction": null,
              "question": {
                "title": "Define a Convolution Layer in TensorFlow",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5571463753105408",
                "initial_code_files": [
                  {
                    "text": "\"\"\"\nSetup the strides, padding and filter weight/bias such that\nthe output shape is (1, 2, 2, 3).\n\"\"\"\nimport tensorflow as tf\nimport numpy as np\n\n# `tf.nn.conv2d` requires the input be 4D (batch_size, height, width, depth)\n# (1, 4, 4, 1)\nx = np.array([\n    [0, 1, 0.5, 10],\n    [2, 2.5, 1, -8],\n    [4, 0, 5, 6],\n    [15, 1, 2, 3]], dtype=np.float32).reshape((1, 4, 4, 1))\nX = tf.constant(x)\n\n\ndef conv2d(input):\n    # Filter (weights and bias)\n    # The shape of the filter weight is (height, width, input_depth, output_depth)\n    # The shape of the filter bias is (output_depth,)\n    # TODO: Define the filter weights `F_W` and filter bias `F_b`.\n    # NOTE: Remember to wrap them in `tf.Variable`, they are trainable parameters after all.\n    F_W = ?\n    F_b = ?\n    # TODO: Set the stride for each dimension (batch_size, height, width, depth)\n    strides = [?, ?, ?, ?]\n    # TODO: set the padding, either 'VALID' or 'SAME'.\n    padding = ?\n    # https://www.tensorflow.org/versions/r0.11/api_docs/python/nn.html#conv2d\n    # `tf.nn.conv2d` does not include the bias computation so we have to add it ourselves after.\n    return tf.nn.conv2d(input, F_W, strides, padding) + F_b\n\nout = conv2d(X)\n\n\n\n",
                    "name": "conv.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 217153,
          "key": "7c8247d8-1332-4044-b2ae-6ab186ffd393",
          "title": "Solution: TensorFlow Convolution Layer",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217177,
              "key": "4f2d49ac-3fcb-41e9-b8b8-6a700afe79ee",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nHere's how I did it. **NOTE**: there's more than 1 way to get the correct output shape. Your answer might differ from mine.",
              "instructor_notes": ""
            },
            {
              "id": 217169,
              "key": "024c8f5a-4749-482c-8f47-735a1c595b0c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```python\ndef conv2d(input):\n    # Filter (weights and bias)\n    F_W = tf.Variable(tf.truncated_normal((2, 2, 1, 3)))\n    F_b = tf.Variable(tf.zeros(3))\n    strides = [1, 2, 2, 1]\n    padding = 'VALID'\n    return tf.nn.conv2d(input, F_W, strides, padding) + F_b\n```",
              "instructor_notes": ""
            },
            {
              "id": 217178,
              "key": "306ff652-33ed-4589-a348-663a02290ff8",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "I want to transform the input shape `(1, 4, 4, 1)` to `(1, 2, 2, 3)`. I choose `'VALID'` for the padding algorithm. I find it simpler to understand and it achieves the result I'm looking for.\n\n```sh\nout_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))\nout_width  = ceil(float(in_width - filter_width + 1) / float(strides[2]))\n```\n\nPlugging in the values:\n\n```sh\nout_height = ceil(float(4 - 2 + 1) / float(2)) = ceil(1.5) = 2\nout_width  = ceil(float(4 - 2 + 1) / float(2)) = ceil(1.5) = 2\n```\n\nIn order to change the depth from 1 to 3, I have to set the output depth of my filter appropriately:\n\n```python\nF_W = tf.Variable(tf.truncated_normal((2, 2, 1, 3))) # (height, width, input_depth, output_depth)\nF_b = tf.Variable(tf.zeros(3)) # (output_depth)\n```\nThe input has a depth of 1, so I set that as the `input_depth` of the filter.\n\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 217148,
          "key": "ce2aa7d8-ee13-4166-8d65-5e52fd79995c",
          "title": "TensorFlow Pooling Layer",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217149,
              "key": "ee9971f5-b530-4cda-999a-f8d74581a3ec",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Using Pooling Layers in TensorFlow\n\nIn the below exercise, you'll be asked to set up the dimensions of the pooling filters, strides, as well as the appropriate padding. You should go over the TensorFlow documentation for [`tf.nn.max_pool()`](https://www.tensorflow.org/api_docs/python/tf/nn/max_pool). Padding works the same as it does for a convolution.\n\n\n### Instructions\n\n1. Finish off each `TODO` in the `maxpool` function.\n\n2. Setup the `strides`, `padding` and `ksize` such that the output shape after pooling is `(1, 2, 2, 1)`.",
              "instructor_notes": ""
            },
            {
              "id": 217150,
              "key": "e47eb131-f824-4f81-93a1-cfb877c30339",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "instruction": null,
              "question": {
                "title": "Define a Pooling Layer in TensorFlow",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6246286330298368",
                "initial_code_files": [
                  {
                    "text": "\"\"\"\nSet the values to `strides` and `ksize` such that\nthe output shape after pooling is (1, 2, 2, 1).\n\"\"\"\nimport tensorflow as tf\nimport numpy as np\n\n# `tf.nn.max_pool` requires the input be 4D (batch_size, height, width, depth)\n# (1, 4, 4, 1)\nx = np.array([\n    [0, 1, 0.5, 10],\n    [2, 2.5, 1, -8],\n    [4, 0, 5, 6],\n    [15, 1, 2, 3]], dtype=np.float32).reshape((1, 4, 4, 1))\nX = tf.constant(x)\n\ndef maxpool(input):\n    # TODO: Set the ksize (filter size) for each dimension (batch_size, height, width, depth)\n    ksize = [?, ?, ?, ?]\n    # TODO: Set the stride for each dimension (batch_size, height, width, depth)\n    strides = [?, ?, ?, ?]\n    # TODO: set the padding, either 'VALID' or 'SAME'.\n    padding = ?\n    # https://www.tensorflow.org/versions/r0.11/api_docs/python/nn.html#max_pool\n    return tf.nn.max_pool(input, ksize, strides, padding)\n    \nout = maxpool(X)",
                    "name": "pool.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 217154,
          "key": "5e0067dc-3a3d-49ec-8a88-f11ac946f507",
          "title": "Solution: TensorFlow Pooling Layer",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 217176,
              "key": "21e09004-4bc7-4480-949e-1fe63cf437ad",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Solution\n\nHere's how I did it. **NOTE**: there's more than 1 way to get the correct output shape. Your answer might differ from mine.",
              "instructor_notes": ""
            },
            {
              "id": 217170,
              "key": "d0beac6a-824a-4ce4-89d6-ed019ed74c31",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```python\ndef maxpool(input):\n    ksize = [1, 2, 2, 1]\n    strides = [1, 2, 2, 1]\n    padding = 'VALID'\n    return tf.nn.max_pool(input, ksize, strides, padding)\n```",
              "instructor_notes": ""
            },
            {
              "id": 217175,
              "key": "b3ce2acc-496e-4a4d-91d2-7dc04f555f96",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "I want to transform the input shape `(1, 4, 4, 1)` to `(1, 2, 2, 1)`. I choose `'VALID'` for the padding algorithm. I find it simpler to understand and it achieves the result I'm looking for.\n\n```sh\nout_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))\nout_width  = ceil(float(in_width - filter_width + 1) / float(strides[2]))\n```\n\nPlugging in the values:\n\n```sh\nout_height = ceil(float(4 - 2 + 1) / float(2)) = ceil(1.5) = 2\nout_width  = ceil(float(4 - 2 + 1) / float(2)) = ceil(1.5) = 2\n```\n\nThe depth doesn't change during a pooling operation so I don't have to worry about that.\n\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 216782,
          "key": "01a36ddb-1e9a-47db-95b7-d0093aed970d",
          "title": "CNNs - Additional Resources",
          "semantic_type": "Concept",
          "is_public": true,
          "resources": null,
          "atoms": [
            {
              "id": 216783,
              "key": "629f2f90-c4ef-4a93-a877-05185577fd6d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Additional Resources\n\nThere are many wonderful free resources that allow you to go into more depth around Convolutional Neural Networks. In this course, our goal is to give you just enough intuition to start applying this concept on real world problems so you have enough of an exposure to explore more on your own. We strongly encourage you to explore some of these resources more to reinforce your intuition and explore different ideas.\n\nThese are the resources we recommend in particular:\n\n- Andrej Karpathy's [CS231n Stanford course](http://cs231n.github.io/) on Convolutional Neural Networks.\n- Michael Nielsen's [free book](http://neuralnetworksanddeeplearning.com) on Deep Learning.\n- Goodfellow, Bengio, and Courville's more advanced [free book](http://deeplearningbook.org/) on Deep Learning.",
              "instructor_notes": ""
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}